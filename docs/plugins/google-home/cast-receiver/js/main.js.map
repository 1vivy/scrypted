{"version":3,"file":"main.js","mappings":"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","sources":["webpack:///./dist/server/src/rpc.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/harmony module decorator","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///./dist/common/src/deferred.js","webpack:///./dist/common/src/rtc-signaling.js","webpack:///./dist/docs/plugins/google-home/cast-receiver/src/cast.js"],"sourcesContent":["export function startPeriodicGarbageCollection() {\n    if (!global.gc) {\n        console.warn('rpc peer garbage collection not available: global.gc is not exposed.');\n        return;\n    }\n    try {\n        const g = global;\n        if (g.gc) {\n            return setInterval(() => {\n                g.gc();\n            }, 10000);\n        }\n    }\n    catch (e) {\n    }\n}\nclass RpcProxy {\n    peer;\n    entry;\n    constructorName;\n    proxyProps;\n    proxyOneWayMethods;\n    constructor(peer, entry, constructorName, proxyProps, proxyOneWayMethods) {\n        this.peer = peer;\n        this.entry = entry;\n        this.constructorName = constructorName;\n        this.proxyProps = proxyProps;\n        this.proxyOneWayMethods = proxyOneWayMethods;\n    }\n    toPrimitive() {\n        const peer = this.peer;\n        return `RpcProxy-${peer.selfName}:${peer.peerName}: ${this.constructorName}`;\n    }\n    get(target, p, receiver) {\n        if (p === '__proxy_id')\n            return this.entry.id;\n        if (p === '__proxy_constructor')\n            return this.constructorName;\n        if (p === '__proxy_peer')\n            return this.peer;\n        if (p === RpcPeer.PROPERTY_PROXY_PROPERTIES)\n            return this.proxyProps;\n        if (p === RpcPeer.PROPERTY_PROXY_ONEWAY_METHODS)\n            return this.proxyOneWayMethods;\n        if (p === RpcPeer.PROPERTY_JSON_DISABLE_SERIALIZATION || p === RpcPeer.PROPERTY_JSON_COPY_SERIALIZE_CHILDREN)\n            return;\n        if (p === 'then')\n            return;\n        if (p === 'constructor')\n            return;\n        if (this.proxyProps?.[p] !== undefined)\n            return this.proxyProps?.[p];\n        const handled = RpcPeer.handleFunctionInvocations(this, target, p, receiver);\n        if (handled)\n            return handled;\n        return new Proxy(() => p, this);\n    }\n    set(target, p, value, receiver) {\n        if (p === RpcPeer.finalizerIdSymbol)\n            this.entry.finalizerId = value;\n        return true;\n    }\n    apply(target, thisArg, argArray) {\n        if (Object.isFrozen(this.peer.pendingResults))\n            return Promise.reject(new RPCResultError(this.peer, 'RpcPeer has been killed'));\n        // rpc objects can be functions. if the function is a oneway method,\n        // it will have a null in the oneway method list. this is because\n        // undefined is not JSON serializable.\n        const method = target() || null;\n        const args = [];\n        const serializationContext = {};\n        for (const arg of (argArray || [])) {\n            args.push(this.peer.serialize(arg, serializationContext));\n        }\n        const rpcApply = {\n            type: \"apply\",\n            id: undefined,\n            proxyId: this.entry.id,\n            args,\n            method,\n        };\n        if (this.proxyOneWayMethods?.includes?.(method)) {\n            rpcApply.oneway = true;\n            this.peer.send(rpcApply, undefined, serializationContext);\n            return Promise.resolve();\n        }\n        return this.peer.createPendingResult((id, reject) => {\n            rpcApply.id = id;\n            this.peer.send(rpcApply, reject, serializationContext);\n        });\n    }\n}\n// todo: error constructor adds a \"cause\" variable in Chrome 93, Node v??\nexport class RPCResultError extends Error {\n    cause;\n    constructor(peer, message, cause, options) {\n        super(`${peer.selfName}:${peer.peerName}: ${message}`);\n        this.cause = cause;\n        if (options?.name) {\n            this.name = options?.name;\n        }\n        if (options?.stack) {\n            this.stack = `${peer.peerName}:${peer.selfName}\\n${cause?.stack || options.stack}`;\n        }\n    }\n}\nfunction compileFunction(code, params, options) {\n    params = params || [];\n    const f = `(function(${params.join(',')}) {;${code};})`;\n    return eval(f);\n}\ntry {\n    const fr = FinalizationRegistry;\n}\ncatch (e) {\n    window.WeakRef = class WeakRef {\n        target;\n        constructor(target) {\n            this.target = target;\n        }\n        deref() {\n            return this.target;\n        }\n    };\n    window.FinalizationRegistry = class FinalizationRegistry {\n        register() {\n        }\n    };\n}\nexport class RpcPeer {\n    selfName;\n    peerName;\n    send;\n    idCounter = 1;\n    params = {};\n    pendingResults = {};\n    proxyCounter = 1;\n    localProxied = new Map();\n    localProxyMap = {};\n    remoteWeakProxies = {};\n    finalizers = new FinalizationRegistry(entry => this.finalize(entry));\n    nameDeserializerMap = new Map();\n    constructorSerializerMap = new Map();\n    transportSafeArgumentTypes = RpcPeer.getDefaultTransportSafeArgumentTypes();\n    static finalizerIdSymbol = Symbol('rpcFinalizerId');\n    static getDefaultTransportSafeArgumentTypes() {\n        const jsonSerializable = new Set();\n        jsonSerializable.add(Number.name);\n        jsonSerializable.add(String.name);\n        jsonSerializable.add(Object.name);\n        jsonSerializable.add(Boolean.name);\n        jsonSerializable.add(Array.name);\n        return jsonSerializable;\n    }\n    static handleFunctionInvocations(thiz, target, p, receiver) {\n        if (p === 'apply') {\n            return (thisArg, args) => {\n                return thiz.apply(target, thiz, args);\n            };\n        }\n        else if (p === 'call') {\n            return (thisArg, ...args) => {\n                return thiz.apply(target, thiz, args);\n            };\n        }\n        else if (p === 'toString' || p === Symbol.toPrimitive) {\n            return (thisArg, ...args) => {\n                return thiz.toPrimitive();\n            };\n        }\n    }\n    static PROPERTY_PROXY_ONEWAY_METHODS = '__proxy_oneway_methods';\n    static PROPERTY_JSON_DISABLE_SERIALIZATION = '__json_disable_serialization';\n    static PROPERTY_PROXY_PROPERTIES = '__proxy_props';\n    static PROPERTY_JSON_COPY_SERIALIZE_CHILDREN = '__json_copy_serialize_children';\n    static PROBED_PROPERTIES = new Set([\n        'then',\n        'constructor',\n        '__proxy_id',\n        '__proxy_constructor',\n        '__proxy_peer',\n        RpcPeer.PROPERTY_PROXY_ONEWAY_METHODS,\n        RpcPeer.PROPERTY_JSON_DISABLE_SERIALIZATION,\n        RpcPeer.PROPERTY_PROXY_PROPERTIES,\n        RpcPeer.PROPERTY_JSON_COPY_SERIALIZE_CHILDREN,\n    ]);\n    constructor(selfName, peerName, send) {\n        this.selfName = selfName;\n        this.peerName = peerName;\n        this.send = send;\n    }\n    createPendingResult(cb) {\n        if (Object.isFrozen(this.pendingResults))\n            return Promise.reject(new RPCResultError(this, 'RpcPeer has been killed'));\n        const promise = new Promise((resolve, reject) => {\n            const id = (this.idCounter++).toString();\n            this.pendingResults[id] = { resolve, reject };\n            cb(id, e => reject(new RPCResultError(this, e.message, e)));\n        });\n        // todo: make this an option so rpc doesn't nuke the process if uncaught?\n        promise.catch(() => { });\n        return promise;\n    }\n    kill(message) {\n        const error = new RPCResultError(this, message || 'peer was killed');\n        for (const result of Object.values(this.pendingResults)) {\n            result.reject(error);\n        }\n        this.pendingResults = Object.freeze({});\n        this.remoteWeakProxies = Object.freeze({});\n        this.localProxyMap = Object.freeze({});\n        this.localProxied.clear();\n    }\n    // need a name/constructor map due to babel name mangling? fix somehow?\n    addSerializer(ctr, name, serializer) {\n        this.nameDeserializerMap.set(name, serializer);\n        this.constructorSerializerMap.set(ctr, name);\n    }\n    finalize(entry) {\n        delete this.remoteWeakProxies[entry.id];\n        const rpcFinalize = {\n            __local_proxy_id: entry.id,\n            __local_proxy_finalizer_id: entry.finalizerId,\n            type: 'finalize',\n        };\n        this.send(rpcFinalize);\n    }\n    async getParam(param) {\n        return this.createPendingResult((id, reject) => {\n            const paramMessage = {\n                id,\n                type: 'param',\n                param,\n            };\n            this.send(paramMessage, reject);\n        });\n    }\n    evalLocal(script, filename, coercedParams) {\n        const params = Object.assign({}, this.params, coercedParams);\n        let compile;\n        try {\n            // prevent bundlers from trying to include non-existent vm module.\n            compile = module[`require`]('vm').compileFunction;\n        }\n        catch (e) {\n            compile = compileFunction;\n        }\n        const f = compile(script, Object.keys(params), {\n            filename,\n        });\n        const value = f(...Object.values(params));\n        return value;\n    }\n    createErrorResult(result, e) {\n        result.stack = e.stack || 'no stack';\n        result.result = e.name || 'no name';\n        result.message = e.message || 'no message';\n    }\n    deserialize(value, deserializationContext) {\n        if (!value)\n            return value;\n        const copySerializeChildren = value[RpcPeer.PROPERTY_JSON_COPY_SERIALIZE_CHILDREN];\n        if (copySerializeChildren) {\n            const ret = {};\n            for (const [key, val] of Object.entries(value)) {\n                ret[key] = this.deserialize(val, deserializationContext);\n            }\n            return ret;\n        }\n        const { __remote_proxy_id, __remote_proxy_finalizer_id, __local_proxy_id, __remote_constructor_name, __serialized_value, __remote_proxy_props, __remote_proxy_oneway_methods } = value;\n        if (__remote_proxy_id) {\n            let proxy = this.remoteWeakProxies[__remote_proxy_id]?.deref();\n            if (!proxy)\n                proxy = this.newProxy(__remote_proxy_id, __remote_constructor_name, __remote_proxy_props, __remote_proxy_oneway_methods);\n            proxy[RpcPeer.finalizerIdSymbol] = __remote_proxy_finalizer_id;\n            return proxy;\n        }\n        if (__local_proxy_id) {\n            const ret = this.localProxyMap[__local_proxy_id];\n            if (!ret)\n                throw new RPCResultError(this, `invalid local proxy id ${__local_proxy_id}`);\n            return ret;\n        }\n        const deserializer = this.nameDeserializerMap.get(__remote_constructor_name);\n        if (deserializer) {\n            return deserializer.deserialize(__serialized_value, deserializationContext);\n        }\n        return value;\n    }\n    serialize(value, serializationContext) {\n        if (value?.[RpcPeer.PROPERTY_JSON_COPY_SERIALIZE_CHILDREN] === true) {\n            const ret = {};\n            for (const [key, val] of Object.entries(value)) {\n                ret[key] = this.serialize(val, serializationContext);\n            }\n            return ret;\n        }\n        if (!value || (!value[RpcPeer.PROPERTY_JSON_DISABLE_SERIALIZATION] && this.transportSafeArgumentTypes.has(value.constructor?.name))) {\n            return value;\n        }\n        let __remote_constructor_name = value.__proxy_constructor || value.constructor?.name?.toString();\n        let proxiedEntry = this.localProxied.get(value);\n        if (proxiedEntry) {\n            const __remote_proxy_finalizer_id = (this.proxyCounter++).toString();\n            proxiedEntry.finalizerId = __remote_proxy_finalizer_id;\n            const ret = {\n                __remote_proxy_id: proxiedEntry.id,\n                __remote_proxy_finalizer_id,\n                __remote_constructor_name,\n                __remote_proxy_props: value?.[RpcPeer.PROPERTY_PROXY_PROPERTIES],\n                __remote_proxy_oneway_methods: value?.[RpcPeer.PROPERTY_PROXY_ONEWAY_METHODS],\n            };\n            return ret;\n        }\n        const { __proxy_id, __proxy_peer } = value;\n        if (__proxy_id && __proxy_peer === this) {\n            const ret = {\n                __local_proxy_id: __proxy_id,\n            };\n            return ret;\n        }\n        const serializerMapName = this.constructorSerializerMap.get(value.constructor);\n        if (serializerMapName) {\n            __remote_constructor_name = serializerMapName;\n            const serializer = this.nameDeserializerMap.get(serializerMapName);\n            if (!serializer)\n                throw new Error('serializer not found for ' + serializerMapName);\n            const serialized = serializer.serialize(value, serializationContext);\n            const ret = {\n                __remote_proxy_id: undefined,\n                __remote_proxy_finalizer_id: undefined,\n                __remote_constructor_name,\n                __remote_proxy_props: value?.[RpcPeer.PROPERTY_PROXY_PROPERTIES],\n                __remote_proxy_oneway_methods: value?.[RpcPeer.PROPERTY_PROXY_ONEWAY_METHODS],\n                __serialized_value: serialized,\n            };\n            return ret;\n        }\n        const __remote_proxy_id = (this.proxyCounter++).toString();\n        proxiedEntry = {\n            id: __remote_proxy_id,\n            finalizerId: __remote_proxy_id,\n        };\n        this.localProxied.set(value, proxiedEntry);\n        this.localProxyMap[__remote_proxy_id] = value;\n        const ret = {\n            __remote_proxy_id,\n            __remote_proxy_finalizer_id: __remote_proxy_id,\n            __remote_constructor_name,\n            __remote_proxy_props: value?.[RpcPeer.PROPERTY_PROXY_PROPERTIES],\n            __remote_proxy_oneway_methods: value?.[RpcPeer.PROPERTY_PROXY_ONEWAY_METHODS],\n        };\n        return ret;\n    }\n    newProxy(proxyId, proxyConstructorName, proxyProps, proxyOneWayMethods) {\n        const localProxiedEntry = {\n            id: proxyId,\n            finalizerId: undefined,\n        };\n        const rpc = new RpcProxy(this, localProxiedEntry, proxyConstructorName, proxyProps, proxyOneWayMethods);\n        const target = proxyConstructorName === 'Function' || proxyConstructorName === 'AsyncFunction' ? function () { } : rpc;\n        const proxy = new Proxy(target, rpc);\n        const weakref = new WeakRef(proxy);\n        this.remoteWeakProxies[proxyId] = weakref;\n        this.finalizers.register(rpc, localProxiedEntry);\n        return proxy;\n    }\n    async handleMessage(message, deserializationContext) {\n        try {\n            switch (message.type) {\n                case 'param': {\n                    const rpcParam = message;\n                    const serializationContext = {};\n                    const result = {\n                        type: 'result',\n                        id: rpcParam.id,\n                        result: this.serialize(this.params[rpcParam.param], serializationContext)\n                    };\n                    this.send(result, undefined, serializationContext);\n                    break;\n                }\n                case 'apply': {\n                    const rpcApply = message;\n                    const result = {\n                        type: 'result',\n                        id: rpcApply.id || '',\n                    };\n                    const serializationContext = {};\n                    try {\n                        const target = this.localProxyMap[rpcApply.proxyId];\n                        if (!target)\n                            throw new Error(`proxy id ${rpcApply.proxyId} not found`);\n                        const args = [];\n                        for (const arg of (rpcApply.args || [])) {\n                            args.push(this.deserialize(arg, deserializationContext));\n                        }\n                        let value;\n                        if (rpcApply.method) {\n                            const method = target[rpcApply.method];\n                            if (!method)\n                                throw new Error(`target ${target?.constructor?.name} does not have method ${rpcApply.method}`);\n                            value = await target[rpcApply.method](...args);\n                        }\n                        else {\n                            value = await target(...args);\n                        }\n                        result.result = this.serialize(value, serializationContext);\n                    }\n                    catch (e) {\n                        // console.error('failure', rpcApply.method, e);\n                        this.createErrorResult(result, e);\n                    }\n                    if (!rpcApply.oneway)\n                        this.send(result, undefined, serializationContext);\n                    break;\n                }\n                case 'result': {\n                    const rpcResult = message;\n                    const deferred = this.pendingResults[rpcResult.id];\n                    delete this.pendingResults[rpcResult.id];\n                    if (!deferred)\n                        throw new Error(`unknown result ${rpcResult.id}`);\n                    if (rpcResult.message || rpcResult.stack) {\n                        const e = new RPCResultError(this, rpcResult.message || 'no message', undefined, {\n                            name: rpcResult.result,\n                            stack: rpcResult.stack,\n                        });\n                        deferred.reject(e);\n                        return;\n                    }\n                    deferred.resolve(this.deserialize(rpcResult.result, deserializationContext));\n                    break;\n                }\n                case 'finalize': {\n                    const rpcFinalize = message;\n                    const local = this.localProxyMap[rpcFinalize.__local_proxy_id];\n                    if (local) {\n                        const localProxiedEntry = this.localProxied.get(local);\n                        // if a finalizer id is specified, it must match.\n                        if (rpcFinalize.__local_proxy_finalizer_id && rpcFinalize.__local_proxy_finalizer_id !== localProxiedEntry?.finalizerId) {\n                            break;\n                        }\n                        delete this.localProxyMap[rpcFinalize.__local_proxy_id];\n                        this.localProxied.delete(local);\n                    }\n                    break;\n                }\n                default:\n                    throw new Error(`unknown rpc message type ${message.type}`);\n            }\n        }\n        catch (e) {\n            console.error('unhandled rpc error', this.peerName, e);\n            return;\n        }\n    }\n}\nexport function getEvalSource() {\n    return `\n    (() => {\n        ${RpcProxy}\n\n        ${RpcPeer}\n    \n        return {\n            RpcPeer,\n            RpcProxy,\n        };\n    })();\n    `;\n}\n//# sourceMappingURL=rpc.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.hmd = (module) => {\n\tmodule = Object.create(module);\n\tif (!module.children) module.children = [];\n\tObject.defineProperty(module, 'exports', {\n\t\tenumerable: true,\n\t\tset: () => {\n\t\t\tthrow new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);\n\t\t}\n\t});\n\treturn module;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export class Deferred {\n    finished = false;\n    resolve;\n    reject;\n    promise = new Promise((resolve, reject) => {\n        this.resolve = v => {\n            this.finished = true;\n            resolve(v);\n        };\n        this.reject = e => {\n            this.finished = true;\n            reject(e);\n        };\n    });\n}\n//# sourceMappingURL=deferred.js.map","import { Deferred } from \"./deferred\";\nfunction getUserAgent() {\n    try {\n        return navigator.userAgent;\n    }\n    catch (e) {\n    }\n}\n// connectionState is not implemented in firefox? so watch iceConnectionState instead...\nexport function waitPeerConnectionIceConnected(pc) {\n    return new Promise((resolve, reject) => {\n        if (pc.iceConnectionState === 'connected') {\n            resolve(undefined);\n            return;\n        }\n        pc.addEventListener('iceconnectionstatechange', () => {\n            if (pc.iceConnectionState === 'connected')\n                resolve(undefined);\n        });\n        waitPeerIceConnectionClosed(pc).then(reason => reject(new Error(reason)));\n    });\n}\nexport function waitPeerIceConnectionClosed(pc) {\n    return new Promise(resolve => {\n        pc.addEventListener('iceconnectionstatechange', () => {\n            if (isPeerConnectionClosed(pc)) {\n                resolve(pc.iceConnectionState);\n            }\n        });\n    });\n}\nexport function isPeerConnectionClosed(pc) {\n    return pc.iceConnectionState === 'disconnected'\n        || pc.iceConnectionState === 'failed'\n        || pc.iceConnectionState === 'closed';\n}\nexport class BrowserSignalingSession {\n    pc;\n    pcDeferred = new Deferred();\n    dcDeferred = new Deferred();\n    options = {\n        userAgent: getUserAgent(),\n        capabilities: {\n            audio: RTCRtpReceiver.getCapabilities?.('audio') || {\n                codecs: undefined,\n                headerExtensions: undefined,\n            },\n            video: RTCRtpReceiver.getCapabilities?.('video') || {\n                codecs: undefined,\n                headerExtensions: undefined,\n            },\n        },\n        screen: {\n            width: screen.width,\n            height: screen.height,\n        },\n    };\n    constructor() {\n    }\n    async getOptions() {\n        return this.options;\n    }\n    close() {\n        this.pcDeferred.promise.then(pc => {\n            for (const t of pc.getTransceivers() || []) {\n                try {\n                    t.sender?.track?.stop?.();\n                }\n                catch (e) {\n                }\n            }\n            pc.close();\n        })\n            .catch(() => { });\n        this.pcDeferred.reject(new Error('iceConnectionState ' + this.pc?.iceConnectionState));\n    }\n    async createPeerConnection(setup) {\n        if (this.pc)\n            return;\n        const checkConn = () => {\n            console.log('iceConnectionState', pc.iceConnectionState);\n            console.log('connectionState', pc.connectionState);\n            if (isPeerConnectionClosed(pc))\n                this.close();\n        };\n        const pc = this.pc = new RTCPeerConnection(setup.configuration);\n        this.pcDeferred.resolve(pc);\n        pc.addEventListener('connectionstatechange', checkConn);\n        pc.addEventListener('iceconnectionstatechange', checkConn);\n        pc.addEventListener('icegatheringstatechange', ev => console.log('iceGatheringState', pc.iceGatheringState));\n        pc.addEventListener('signalingstatechange', ev => console.log('signalingState', pc.signalingState));\n        pc.addEventListener('icecandidateerror', ev => console.log('icecandidateerror'));\n        if (setup.datachannel) {\n            const dc = pc.createDataChannel(setup.datachannel.label, setup.datachannel.dict);\n            dc.binaryType = 'arraybuffer';\n            this.dcDeferred.resolve(dc);\n        }\n        if (setup.audio) {\n            if (setup.audio.direction === 'sendrecv' || setup.audio.direction === 'sendonly') {\n                try {\n                    // doing sendrecv on safari requires a mic be attached, or it fails to connect.\n                    const mic = await navigator.mediaDevices.getUserMedia({ video: false, audio: true });\n                    for (const track of mic.getTracks()) {\n                        pc.addTrack(track);\n                    }\n                }\n                catch (e) {\n                    let silence = () => {\n                        let ctx = new AudioContext(), oscillator = ctx.createOscillator();\n                        const dest = ctx.createMediaStreamDestination();\n                        oscillator.connect(dest);\n                        oscillator.start();\n                        return Object.assign(dest.stream.getAudioTracks()[0], { enabled: false });\n                    };\n                    pc.addTrack(silence());\n                }\n            }\n            else {\n                pc.addTransceiver('audio', setup.audio);\n            }\n        }\n        if (setup.video) {\n            if (setup.video.direction === 'sendrecv' || setup.video.direction === 'sendonly') {\n                try {\n                    // doing sendrecv on safari requires a mic be attached, or it fails to connect.\n                    const camera = await navigator.mediaDevices.getUserMedia({ video: true });\n                    for (const track of camera.getTracks()) {\n                        pc.addTrack(track);\n                    }\n                }\n                catch (e) {\n                    // what now\n                }\n            }\n            else {\n                pc.addTransceiver('video', setup.video);\n            }\n        }\n    }\n    async createLocalDescription(type, setup, sendIceCandidate) {\n        await this.createPeerConnection(setup);\n        const gatheringPromise = new Promise(resolve => {\n            this.pc.onicecandidate = ev => {\n                if (ev.candidate) {\n                    console.log(\"local candidate\", ev.candidate);\n                    sendIceCandidate?.(JSON.parse(JSON.stringify(ev.candidate)));\n                }\n                else {\n                    resolve(undefined);\n                }\n            };\n            this.pc.onicegatheringstatechange = () => {\n                if (this.pc.iceGatheringState === 'complete')\n                    resolve(undefined);\n            };\n        });\n        const toDescription = (init) => {\n            // console.log('local description', init.sdp);\n            return {\n                type: init.type,\n                sdp: init.sdp,\n            };\n        };\n        if (type === 'offer') {\n            let offer = await this.pc.createOffer({\n                offerToReceiveAudio: !!setup.audio,\n                offerToReceiveVideo: !!setup.video,\n            });\n            const set = this.pc.setLocalDescription(offer);\n            if (sendIceCandidate)\n                return toDescription(offer);\n            await set;\n            await gatheringPromise;\n            offer = await this.pc.createOffer({\n                offerToReceiveAudio: !!setup.audio,\n                offerToReceiveVideo: !!setup.video,\n            });\n            return toDescription(offer);\n        }\n        else {\n            let answer = await this.pc.createAnswer();\n            const set = this.pc.setLocalDescription(answer);\n            if (sendIceCandidate)\n                return toDescription(answer);\n            await set;\n            await gatheringPromise;\n            answer = this.pc.currentLocalDescription || answer;\n            return toDescription(answer);\n        }\n    }\n    async setRemoteDescription(description, setup) {\n        await this.createPeerConnection(setup);\n        await this.pc.setRemoteDescription(description);\n        // console.log('remote description', description.sdp);\n    }\n    async addIceCandidate(candidate) {\n        await this.pc.addIceCandidate(candidate);\n        // console.log(\"remote candidate\", candidate);\n    }\n    async endSession() {\n    }\n}\nfunction logSendCandidate(console, type, session) {\n    return async (candidate) => {\n        // console.log(`${type} trickled candidate:`, candidate.sdpMLineIndex, candidate.candidate);\n        return session.addIceCandidate(candidate);\n    };\n}\nfunction createCandidateQueue(console, type, session) {\n    let ready = false;\n    let candidateQueue = [];\n    const ls = logSendCandidate(console, type, session);\n    const queueSendCandidate = async (candidate) => {\n        if (!ready)\n            candidateQueue.push(candidate);\n        else\n            ls(candidate);\n    };\n    return {\n        flush() {\n            ready = true;\n            for (const candidate of candidateQueue) {\n                ls(candidate);\n            }\n            candidateQueue = [];\n        },\n        queueSendCandidate,\n    };\n}\nexport async function connectRTCSignalingClients(console, offerClient, offerSetup, answerClient, answerSetup) {\n    const offerOptions = await offerClient.getOptions();\n    const answerOptions = await answerClient.getOptions();\n    const disableTrickle = offerOptions?.disableTrickle || answerOptions?.disableTrickle;\n    if (offerOptions?.offer && answerOptions?.offer)\n        throw new Error('Both RTC clients have offers and can not negotiate. Consider implementing this in @scrypted/webrtc.');\n    if (offerOptions?.requiresOffer && answerOptions.requiresOffer)\n        throw new Error('Both RTC clients require offers and can not negotiate.');\n    offerSetup.type = 'offer';\n    answerSetup.type = 'answer';\n    const answerQueue = createCandidateQueue(console, 'offer', answerClient);\n    const offerQueue = createCandidateQueue(console, 'answer', offerClient);\n    const offer = await offerClient.createLocalDescription('offer', offerSetup, disableTrickle ? undefined : answerQueue.queueSendCandidate);\n    // console.log('offer sdp', offer.sdp);\n    await answerClient.setRemoteDescription(offer, answerSetup);\n    answerQueue.flush();\n    const answer = await answerClient.createLocalDescription('answer', answerSetup, disableTrickle ? undefined : offerQueue.queueSendCandidate);\n    // console.log('answer sdp', answer.sdp);\n    await offerClient.setRemoteDescription(answer, offerSetup);\n    offerQueue.flush();\n}\n//# sourceMappingURL=rtc-signaling.js.map","import { RpcPeer } from '../../../../../server/src/rpc';\nimport { BrowserSignalingSession } from '../../../../../common/src/rtc-signaling';\ndocument.addEventListener(\"DOMContentLoaded\", function (event) {\n    const options = new cast.framework.CastReceiverOptions();\n    options.disableIdleTimeout = true;\n    cast.framework.CastReceiverContext.getInstance().start(options);\n    const context = cast.framework.CastReceiverContext.getInstance();\n    const playerManager = context.getPlayerManager();\n    const video = document.getElementById('media');\n    // intercept the LOAD request to be able to read in a contentId and get data\n    const interceptor = (loadRequestData) => {\n        console.log(loadRequestData);\n        const eioUrl = loadRequestData.media.entity || loadRequestData.media.contentId;\n        const token = loadRequestData.credentials ?? loadRequestData.media.customData.token;\n        const url = new URL(eioUrl);\n        const endpointPath = url.pathname;\n        const query = {};\n        for (const [k, v] of new URLSearchParams(url.search)) {\n            query[k] = v;\n        }\n        const options = {\n            path: endpointPath,\n            query,\n        };\n        const socket = eio(`wss://${url.host}`, options);\n        socket.on('open', async () => {\n            socket.send(JSON.stringify({\n                token,\n            }));\n            const rpcPeer = new RpcPeer('cast-receiver', 'host', (message, reject) => {\n                try {\n                    socket.send(JSON.stringify(message));\n                }\n                catch (e) {\n                    reject?.(e);\n                }\n            });\n            socket.on('message', (data) => {\n                rpcPeer.handleMessage(JSON.parse(data));\n            });\n            const cleanup = () => window.close();\n            const session = new BrowserSignalingSession();\n            session.pcDeferred.promise.then(pc => {\n                pc.addEventListener('connectionstatechange', () => {\n                    if (pc.iceConnectionState === 'disconnected'\n                        || pc.iceConnectionState === 'failed'\n                        || pc.iceConnectionState === 'closed') {\n                        cleanup();\n                    }\n                });\n                pc.addEventListener('iceconnectionstatechange', () => {\n                    console.log('iceConnectionStateChange', pc.connectionState, pc.iceConnectionState);\n                    if (pc.iceConnectionState === 'disconnected'\n                        || pc.iceConnectionState === 'failed'\n                        || pc.iceConnectionState === 'closed') {\n                        cleanup();\n                    }\n                });\n                const mediaStream = new MediaStream(pc.getReceivers().map((receiver) => receiver.track));\n                pc.ontrack = e => mediaStream.addTrack(e.track);\n                video.srcObject = mediaStream;\n            });\n            rpcPeer.params['session'] = session;\n        });\n        return null;\n    };\n    playerManager.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, interceptor);\n});\n//# sourceMappingURL=cast.js.map"],"names":["startPeriodicGarbageCollection","g","gc","setInterval","e","console","warn","RpcProxy","peer","entry","constructorName","proxyProps","proxyOneWayMethods","constructor","this","toPrimitive","selfName","peerName","get","target","p","receiver","id","RpcPeer","PROPERTY_PROXY_PROPERTIES","PROPERTY_PROXY_ONEWAY_METHODS","PROPERTY_JSON_DISABLE_SERIALIZATION","PROPERTY_JSON_COPY_SERIALIZE_CHILDREN","undefined","handleFunctionInvocations","Proxy","set","value","finalizerIdSymbol","finalizerId","apply","thisArg","argArray","Object","isFrozen","pendingResults","Promise","reject","RPCResultError","method","args","serializationContext","arg","push","serialize","rpcApply","type","proxyId","includes","oneway","send","resolve","createPendingResult","Error","cause","message","options","super","name","stack","compileFunction","code","params","f","join","eval","fr","FinalizationRegistry","window","WeakRef","deref","register","idCounter","proxyCounter","localProxied","Map","localProxyMap","remoteWeakProxies","finalizers","finalize","nameDeserializerMap","constructorSerializerMap","transportSafeArgumentTypes","getDefaultTransportSafeArgumentTypes","static","Symbol","jsonSerializable","Set","add","Number","String","Boolean","Array","thiz","cb","promise","toString","catch","kill","error","result","values","freeze","clear","addSerializer","ctr","serializer","rpcFinalize","__local_proxy_id","__local_proxy_finalizer_id","async","param","paramMessage","evalLocal","script","filename","coercedParams","assign","compile","module","keys","createErrorResult","deserialize","deserializationContext","ret","key","val","entries","__remote_proxy_id","__remote_proxy_finalizer_id","__remote_constructor_name","__serialized_value","__remote_proxy_props","__remote_proxy_oneway_methods","proxy","newProxy","deserializer","has","__proxy_constructor","proxiedEntry","__proxy_id","__proxy_peer","serializerMapName","serialized","proxyConstructorName","localProxiedEntry","rpc","weakref","rpcParam","rpcResult","deferred","local","delete","getEvalSource","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","loaded","__webpack_modules__","d","definition","o","defineProperty","enumerable","globalThis","Function","hmd","create","children","obj","prop","prototype","hasOwnProperty","call","Deferred","finished","v","getUserAgent","navigator","userAgent","BrowserSignalingSession","pc","pcDeferred","dcDeferred","capabilities","audio","RTCRtpReceiver","getCapabilities","codecs","headerExtensions","video","screen","width","height","close","then","t","getTransceivers","sender","track","stop","iceConnectionState","setup","checkConn","log","connectionState","isPeerConnectionClosed","RTCPeerConnection","configuration","addEventListener","ev","iceGatheringState","signalingState","datachannel","dc","createDataChannel","label","dict","binaryType","direction","mic","mediaDevices","getUserMedia","getTracks","addTrack","silence","ctx","AudioContext","oscillator","createOscillator","dest","createMediaStreamDestination","connect","start","stream","getAudioTracks","enabled","addTransceiver","camera","sendIceCandidate","createPeerConnection","gatheringPromise","onicecandidate","candidate","JSON","parse","stringify","onicegatheringstatechange","toDescription","init","sdp","offer","createOffer","offerToReceiveAudio","offerToReceiveVideo","setLocalDescription","answer","createAnswer","currentLocalDescription","description","setRemoteDescription","addIceCandidate","document","event","cast","framework","CastReceiverOptions","disableIdleTimeout","CastReceiverContext","getInstance","playerManager","getPlayerManager","getElementById","setMessageInterceptor","messages","MessageType","LOAD","loadRequestData","eioUrl","media","entity","contentId","token","credentials","customData","url","URL","endpointPath","pathname","query","k","URLSearchParams","search","path","socket","eio","host","on","rpcPeer","data","handleMessage","cleanup","session","mediaStream","MediaStream","getReceivers","map","ontrack","srcObject"],"sourceRoot":""}